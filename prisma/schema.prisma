// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --------------------
// CORE TENANCY & USERS
// --------------------

model School {
  id           String   @id @default(cuid())
  name         String   @unique
  address      String?
  contactInfo  String?
  logoUrl      String?
  subdomain    String?  @unique
  customDomain String?  @unique
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  hasParentAppAccess      Boolean @default(false)
  hasAutoTimetable        Boolean @default(false)
  hasFinanceModule        Boolean @default(false)
  hasAdvancedHRModule     Boolean @default(false)
  hasProcurementModule    Boolean @default(false)
  hasLibraryModule        Boolean @default(false)
  hasTransportationModule Boolean @default(false)
  hasHostelModule         Boolean @default(false)

  // Relations
  users                 User[]
  parents               Parent[]
  schoolLevels          SchoolLevel[]
  academicYears         AcademicYear[]
  subjects              Subject[]
  staffMembers          Staff[]
  students              Student[]
  departments           Department[]
  announcements         Announcement[]
  events                Event[]
  gradingScales         GradingScale[]
  classes               Class[]
  sections              Section[]
  studentEnrollments    StudentEnrollment[]
  staffLevelAssignments StaffLevelAssignment[]
  staffSubjectLevels    StaffSubjectLevel[]
  attendances           Attendance[]
  staffAttendances      StaffAttendance[]
  assignments           Assignment[]
  submittedAssignments  SubmittedAssignment[]
  grades                Grade[]
  exams                 Exam[]
  examSchedules         ExamSchedule[]
  examSubjectLinks      ExamSubject[]
  timetableEntries      TimetableEntry[]

  feeStructures       FeeStructure[]
  invoices            Invoice[]
  expenses            Expense[]
  expenseCategories   ExpenseCategory[]
  vendors             Vendor[]
  purchaseOrders      PurchaseOrder[]
  inventoryCategories InventoryCategory[]
  inventoryItems      InventoryItem[]
  invoiceItems        InvoiceItem[]
  payments            Payment[]
  purchaseOrderItems  PurchaseOrderItem[]
  leaveTypes          LeaveType[]
  leaveApplications   LeaveApplication[]
  payrollRecords      PayrollRecord[]
  Term                Term[]

  @@index([subdomain])
  @@index([customDomain])
}

enum UserRole {
  SUPER_ADMIN
  SCHOOL_ADMIN
  SECRETARY
  PROCUREMENT_OFFICER
  TEACHER
  STUDENT
  HR_MANAGER
  ACCOUNTANT
  LIBRARIAN
  TRANSPORT_MANAGER
  HOSTEL_WARDEN
  PARENT
}

model User {
  id                String    @id @default(cuid())
  email             String    @unique
  hashedPassword    String
  firstName         String?
  lastName          String?
  phoneNumber       String?
  profilePictureUrl String?
  role              UserRole
  isActive          Boolean   @default(true)
  lastLogin         DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  schoolId          String?
  school            School?   @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  staffProfile      Staff?
  studentProfile    Student?
  parentProfile     Parent?

  @@index([email])
  @@index([schoolId])
}

model Parent {
  id        String          @id @default(cuid())
  userId    String          @unique
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  address   String?
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  students  ParentStudent[]
  schoolId  String
  school    School          @relation(fields: [schoolId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([schoolId])
}

model ParentStudent {
  parentId          String
  parent            Parent  @relation(fields: [parentId], references: [id], onDelete: Cascade)
  studentId         String
  student           Student @relation(fields: [studentId], references: [id], onDelete: Cascade)
  relationToStudent String?

  @@id([parentId, studentId])
  @@index([studentId])
}

// --------------------
// ACADEMICS & SCHOOL STRUCTURE
// --------------------
model SchoolLevel {
  id          String  @id @default(cuid())
  name        String
  description String?
  schoolId    String
  school      School  @relation(fields: [schoolId], references: [id], onDelete: Cascade)

  classes               Class[] // Back-relation to Class
  staffLevelAssignments StaffLevelAssignment[]
  staffSubjectLevels    StaffSubjectLevel[]    @relation("LevelSubjectsTaught")

  @@unique([schoolId, name])
  @@index([schoolId])
}

model AcademicYear {
  id        String   @id @default(cuid())
  name      String
  startDate DateTime
  endDate   DateTime
  isCurrent Boolean  @default(false)
  schoolId  String
  school    School   @relation(fields: [schoolId], references: [id], onDelete: Cascade)

  terms         Term[]
  enrollments   StudentEnrollment[] // Back-relation to StudentEnrollment
  grades        Grade[]
  feeStructures FeeStructure[]      @relation("YearFeeStructures")
  classes       Class[] // Back-relation to Class

  @@unique([schoolId, name])
  @@index([schoolId])
}

model Term {
  id             String       @id @default(cuid())
  name           String
  startDate      DateTime
  endDate        DateTime
  academicYearId String
  academicYear   AcademicYear @relation(fields: [academicYearId], references: [id], onDelete: Cascade)
  schoolId       String
  school         School       @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  grades         Grade[]
  exams          Exam[]       @relation("TermExams")

  @@unique([academicYearId, name])
  @@index([schoolId])
}

model Department {
  id          String    @id @default(cuid())
  name        String
  description String?
  schoolId    String
  school      School    @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  subjects    Subject[]
  staff       Staff[]

  @@unique([schoolId, name])
  @@index([schoolId])
}

model Class {
  id             String    @id @default(cuid())
  name String

  schoolId String
  school   School @relation(fields: [schoolId], references: [id], onDelete: Restrict)

  schoolLevelId String
  schoolLevel   SchoolLevel @relation(fields: [schoolLevelId], references: [id], onDelete: Cascade)

  academicYearId String
  academicYear   AcademicYear @relation(fields: [academicYearId], references: [id], onDelete: Cascade)

  sections           Section[]
  subjects           Subject[]           @relation("ClassSubjects")
  staffSubjectLevels StaffSubjectLevel[]
  assignments        Assignment[]        @relation("ClassAssignments")
  feeStructures      FeeStructure[]      @relation("ClassFeeStructures")

  createdAt DateTime @default(now()) // This line should be present
  updatedAt DateTime @updatedAt  

  @@unique([schoolId, name, academicYearId, schoolLevelId], map: "UQ_Class_School_Name_Year_Level")
  @@index([schoolId])
  @@index([schoolLevelId])
  @@index([academicYearId])
}

model Section {
  id          String @id @default(cuid())
  name        String
  maxCapacity Int?

  classId String
  class   Class  @relation(fields: [classId], references: [id], onDelete: Cascade)

  // classTeacherId is NOT @unique here, meaning a teacher can be a class teacher for multiple sections.
  // If a teacher should only be a class teacher for ONE section, add @unique to classTeacherId.
  // And change Staff.isClassTeacherForSections to Staff.isClassTeacherForSection (singular, optional).
  classTeacherId String?
  classTeacher   Staff?  @relation("ClassTeacherForSection", fields: [classTeacherId], references: [id], onDelete: SetNull)

  schoolId String
  school   School @relation(fields: [schoolId], references: [id], onDelete: Restrict)

  studentEnrollments StudentEnrollment[]
  timetableEntries   TimetableEntry[]
  attendances        Attendance[]        @relation("SectionAttendances")
  assignments        Assignment[] // Consider if assignments are truly per-section or per-class/subject

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([classId, name], map: "UQ_Section_Class_Name")
  @@index([schoolId])
  @@index([classTeacherId]) // Index if you query by classTeacherId often
}

model Subject {
  id           String      @id @default(cuid())
  name         String
  subjectCode  String?
  description  String?
  departmentId String?
  department   Department? @relation(fields: [departmentId], references: [id], onDelete: SetNull)
  schoolId     String
  school       School      @relation(fields: [schoolId], references: [id], onDelete: Cascade)

  classes            Class[]             @relation("ClassSubjects") // Many-to-many with Class through an implicit join table
  staffSubjectLevels StaffSubjectLevel[]
  assignments        Assignment[]
  examSubjects       ExamSubject[]
  grades             Grade[]
  examSchedules      ExamSchedule[]      @relation("SubjectExamSchedules")
  timetableEntries   TimetableEntry[]    @relation("SubjectTimetableSlots")

  @@unique([schoolId, name])
  @@unique([schoolId, subjectCode]) // If subject codes must be unique per school
  @@index([schoolId])
}

model Student {
  id              String    @id @default(cuid())
  userId          String    @unique
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  studentIdNumber String
  dateOfBirth     DateTime?
  gender          String?
  address         String?
  admissionDate   DateTime  @default(now())
  schoolId        String
  school          School    @relation(fields: [schoolId], references: [id], onDelete: Cascade)

  parents              ParentStudent[]
  enrollments          StudentEnrollment[] // Back-relation
  grades               Grade[]
  submittedAssignments SubmittedAssignment[]
  invoices             Invoice[]

  @@unique([schoolId, studentIdNumber])
  @@index([userId])
  @@index([schoolId])
}

model StudentEnrollment {
  id String @id @default(cuid())

  studentId String
  student   Student @relation(fields: [studentId], references: [id], onDelete: Cascade)

  sectionId String
  section   Section @relation(fields: [sectionId], references: [id], onDelete: Restrict)

  academicYearId String
  academicYear   AcademicYear @relation(fields: [academicYearId], references: [id], onDelete: Restrict)

  schoolId String
  school   School @relation(fields: [schoolId], references: [id], onDelete: Restrict)

  enrollmentDate DateTime @default(now())
  isCurrent      Boolean  @default(true)
  status         String? // e.g., "Active", "Transferred", "Graduated", "Withdrawn" 
  rollNumber     String?

  attendances Attendance[] @relation("EnrollmentAttendances")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([studentId, academicYearId], map: "UQ_Student_AcademicYear_Enrollment")
  @@index([schoolId])
  @@index([sectionId])
  @@index([academicYearId])
  @@index([studentId])
}

model Staff {
  id            String      @id @default(cuid())
  userId        String      @unique
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  staffIdNumber String
  jobTitle      String
  qualification String?
  dateOfJoining DateTime    @default(now())
  departmentId  String?
  department    Department? @relation(fields: [departmentId], references: [id], onDelete: SetNull)
  schoolId      String
  school        School      @relation(fields: [schoolId], references: [id], onDelete: Cascade)

  // If Section.classTeacherId is NOT @unique, this should be Section[]
  // If Section.classTeacherId IS @unique (current schema), this should be Section?
  isClassTeacherForSections Section[] @relation("ClassTeacherForSection") // Changed to Section[] as classTeacherId in Section is not unique

  assignedLevels      StaffLevelAssignment[]
  taughtSubjectLevels StaffSubjectLevel[]
  assignmentsCreated  Assignment[]
  attendances         StaffAttendance[]
  leaveApplications   LeaveApplication[]
  payrollRecords      PayrollRecord[]
  timetableEntries    TimetableEntry[]

  @@unique([schoolId, staffIdNumber])
  @@index([userId])
  @@index([schoolId])
}

model StaffLevelAssignment {
  staffId       String
  staff         Staff       @relation(fields: [staffId], references: [id], onDelete: Cascade)
  schoolLevelId String
  schoolLevel   SchoolLevel @relation(fields: [schoolLevelId], references: [id], onDelete: Cascade)
  assignedAt    DateTime    @default(now())
  schoolId      String
  school        School      @relation(fields: [schoolId], references: [id], onDelete: Restrict)

  @@id([staffId, schoolLevelId])
  @@index([schoolId])
}

model StaffSubjectLevel {
  id            String       @id @default(cuid())
  staffId       String
  staff         Staff        @relation(fields: [staffId], references: [id], onDelete: Cascade)
  subjectId     String
  subject       Subject      @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  schoolLevelId String?
  schoolLevel   SchoolLevel? @relation("LevelSubjectsTaught", fields: [schoolLevelId], references: [id], onDelete: Cascade)
  classId       String?
  class         Class?       @relation(fields: [classId], references: [id], onDelete: Cascade) // If a teacher teaches a subject in a specific class
  schoolId      String
  school        School       @relation(fields: [schoolId], references: [id], onDelete: Restrict)

  @@unique([staffId, subjectId, schoolLevelId, classId])
  @@index([schoolId])
  @@index([staffId])
  @@index([subjectId])
}

// --------------------
// ATTENDANCE
// --------------------
enum AttendanceStatus {
  PRESENT
  ABSENT
  LATE
  EXCUSED
}

model Attendance {
  id                  String            @id @default(cuid())
  studentEnrollmentId String
  studentEnrollment   StudentEnrollment @relation("EnrollmentAttendances", fields: [studentEnrollmentId], references: [id], onDelete: Cascade)
  sectionId           String // Denormalized for easier queries if needed, but studentEnrollment already links to section
  section             Section           @relation("SectionAttendances", fields: [sectionId], references: [id], onDelete: Cascade)
  date                DateTime          @db.Date
  status              AttendanceStatus
  remarks             String?
  takenById           String // User ID of the staff who took attendance
  schoolId            String
  school              School            @relation(fields: [schoolId], references: [id], onDelete: Restrict)

  @@unique([studentEnrollmentId, date])
  @@unique([sectionId, date, studentEnrollmentId], map: "UQ_Attendance_Section_Date_Enrollment") // Ensures one record per student per section per day
  @@index([schoolId, date])
}

model StaffAttendance {
  id       String           @id @default(cuid())
  staffId  String
  staff    Staff            @relation(fields: [staffId], references: [id], onDelete: Cascade)
  date     DateTime         @db.Date
  status   AttendanceStatus
  remarks  String?
  schoolId String
  school   School           @relation(fields: [schoolId], references: [id], onDelete: Restrict)

  @@unique([staffId, date])
  @@index([schoolId, date])
}

// --------------------
// ASSIGNMENTS & GRADES
// --------------------
model Assignment {
  id                   String                @id @default(cuid())
  title                String
  description          String?               @db.Text
  dueDate              DateTime
  subjectId            String
  subject              Subject               @relation(fields: [subjectId], references: [id])
  sectionId            String? // If assignment is for a specific section
  section              Section?              @relation(fields: [sectionId], references: [id])
  classId              String? // If assignment is for a whole class (all sections)
  class                Class?                @relation("ClassAssignments", fields: [classId], references: [id])
  teacherId            String // Staff ID of teacher who created it
  teacher              Staff                 @relation(fields: [teacherId], references: [id])
  maxMarks             Float?
  attachments          Json?
  createdAt            DateTime              @default(now())
  updatedAt            DateTime              @updatedAt
  schoolId             String
  school               School                @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  submittedAssignments SubmittedAssignment[]

  @@index([schoolId, subjectId])
  @@index([sectionId])
  @@index([classId])
}

model SubmittedAssignment {
  id            String     @id @default(cuid())
  assignmentId  String
  assignment    Assignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)
  studentId     String
  student       Student    @relation(fields: [studentId], references: [id], onDelete: Cascade)
  submittedAt   DateTime   @default(now())
  content       String?    @db.Text
  attachments   Json?
  marksObtained Float?
  feedback      String?    @db.Text
  gradedById    String? // Staff ID of grader
  gradedAt      DateTime?
  schoolId      String
  school        School     @relation(fields: [schoolId], references: [id], onDelete: Restrict)

  @@unique([assignmentId, studentId])
  @@index([schoolId])
}

model GradingScale {
  id           String        @id @default(cuid())
  name         String
  description  String?
  schoolId     String
  school       School        @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  gradeDetails GradeDetail[]

  @@unique([schoolId, name])
}

model GradeDetail {
  id             String       @id @default(cuid())
  gradingScaleId String
  gradingScale   GradingScale @relation(fields: [gradingScaleId], references: [id], onDelete: Cascade)
  grade          String
  minPercentage  Float
  maxPercentage  Float
  gpaValue       Float?

  @@unique([gradingScaleId, grade])
}

model Grade {
  id             String        @id @default(cuid())
  studentId      String
  student        Student       @relation(fields: [studentId], references: [id], onDelete: Cascade)
  subjectId      String
  subject        Subject       @relation(fields: [subjectId], references: [id])
  examScheduleId String? // If grade is tied to a specific exam schedule
  examSchedule   ExamSchedule? @relation(fields: [examScheduleId], references: [id], onDelete: SetNull)
  termId         String
  term           Term          @relation(fields: [termId], references: [id])
  academicYearId String
  academicYear   AcademicYear  @relation(fields: [academicYearId], references: [id])
  marksObtained  Float?
  gradeLetter    String?
  gpa            Float?
  comments       String?
  schoolId       String
  school         School        @relation(fields: [schoolId], references: [id], onDelete: Restrict)

  @@index([studentId, subjectId, academicYearId])
  @@index([schoolId])
}

// ... (Rest of your schema: EXAMINATIONS, TIMETABLE, COMMUNICATION, FINANCE, HR, PROCUREMENT) ...
// Ensure these models are complete as per your original full schema.
// For brevity, I'm not re-listing them if they remain unchanged from your previous full schema post.
// Key models like Exam, ExamSchedule, TimetableEntry, Announcement, Event,
// FeeStructure, Invoice, Payment, Expense, LeaveType, PayrollRecord, Vendor, PurchaseOrder, InventoryItem etc.
// should follow here.

// --- Example for a model that was further down (assuming it's unchanged) ---
model Exam {
  id               String         @id @default(cuid())
  name             String
  termId           String
  term             Term           @relation("TermExams", fields: [termId], references: [id], onDelete: Cascade)
  schoolId         String
  school           School         @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  examSchedules    ExamSchedule[] @relation("ExamSchedules")
  examSubjectLinks ExamSubject[]

  @@unique([schoolId, termId, name])
}

// PASTE THE REST OF YOUR MODELS HERE from ExamSchedule onwards...
// Make sure all model definitions are present.

model ExamSchedule {
  id        String   @id @default(cuid())
  examId    String
  exam      Exam     @relation("ExamSchedules", fields: [examId], references: [id], onDelete: Cascade)
  subjectId String
  subject   Subject  @relation("SubjectExamSchedules", fields: [subjectId], references: [id])
  date      DateTime
  startTime String
  endTime   String
  maxMarks  Float
  room      String?
  schoolId  String
  school    School   @relation(fields: [schoolId], references: [id], onDelete: Restrict)
  grades    Grade[]

  @@index([schoolId, examId, subjectId])
}

model ExamSubject {
  examId       String
  exam         Exam    @relation(fields: [examId], references: [id], onDelete: Cascade)
  subjectId    String
  subject      Subject @relation(fields: [subjectId], references: [id])
  maxMarks     Float?
  passingMarks Float?
  schoolId     String
  school       School  @relation(fields: [schoolId], references: [id], onDelete: Restrict)

  @@id([examId, subjectId])
  @@index([schoolId])
}

model TimetableEntry {
  id        String  @id @default(cuid())
  sectionId String
  section   Section @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  subjectId String
  subject   Subject @relation("SubjectTimetableSlots", fields: [subjectId], references: [id])
  staffId   String
  staff     Staff   @relation(fields: [staffId], references: [id])
  dayOfWeek Int // 0 for Sunday, 1 for Monday, etc. or 1-7
  startTime String // e.g., "09:00"
  endTime   String // e.g., "09:45"
  roomNo    String?
  schoolId  String
  school    School  @relation(fields: [schoolId], references: [id], onDelete: Restrict)

  @@index([schoolId, sectionId, dayOfWeek])
  @@index([schoolId, staffId, dayOfWeek])
}

model Announcement {
  id          String    @id @default(cuid())
  title       String
  content     String    @db.Text
  publishedAt DateTime?
  audience    Json? // Could store roles, classes, sections this is for
  isGlobal    Boolean   @default(false) // True if for all schools (e.g., by super admin)
  schoolId    String? // Null if global
  school      School?   @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  authorId    String // User ID of the author
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([schoolId, publishedAt])
}

model Event {
  id          String    @id @default(cuid())
  title       String
  description String?   @db.Text
  startDate   DateTime
  endDate     DateTime?
  schoolId    String?
  school      School?   @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  createdAt   DateTime  @default(now())
  // Consider 'updatedAt DateTime @updatedAt'

  @@index([schoolId, startDate])
}

model FeeStructure {
  id             String        @id @default(cuid())
  name           String
  description    String?
  amount         Float
  frequency      String // e.g., "Monthly", "Termly", "Annually", "One-time"
  academicYearId String
  academicYear   AcademicYear  @relation("YearFeeStructures", fields: [academicYearId], references: [id])
  classId        String? // Optional: if fee structure is specific to a class
  class          Class?        @relation("ClassFeeStructures", fields: [classId], references: [id])
  schoolId       String
  school         School        @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  invoiceItems   InvoiceItem[]

  @@unique([schoolId, name, academicYearId, classId]) // classId can be null, so ensure DB handles nulls in unique constraints if this is desired
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  PARTIALLY_PAID
  OVERDUE
  VOID
  CANCELLED
}

model Invoice {
  id            String        @id @default(cuid())
  invoiceNumber String        @unique // Should be unique per school, or globally? Consider prefixing with school code if global.
  studentId     String
  student       Student       @relation(fields: [studentId], references: [id])
  issueDate     DateTime      @default(now())
  dueDate       DateTime
  totalAmount   Float
  paidAmount    Float         @default(0)
  status        InvoiceStatus @default(DRAFT)
  notes         String?
  schoolId      String
  school        School        @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  items         InvoiceItem[]
  payments      Payment[]

  @@index([schoolId, studentId, status])
}

model InvoiceItem {
  id             String        @id @default(cuid())
  invoiceId      String
  invoice        Invoice       @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  feeStructureId String? // Link to a predefined fee structure item
  feeStructure   FeeStructure? @relation(fields: [feeStructureId], references: [id], onDelete: SetNull)
  description    String // Or custom description if not from fee structure
  quantity       Int           @default(1)
  unitPrice      Float
  totalPrice     Float // quantity * unitPrice
  schoolId       String
  school         School        @relation(fields: [schoolId], references: [id], onDelete: Restrict) // Restrict to prevent accidental deletion if an invoice exists

  @@index([schoolId])
}

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  CREDIT_CARD
  MOBILE_MONEY
  ONLINE_GATEWAY
  OTHER
}

model Payment {
  id            String        @id @default(cuid())
  invoiceId     String
  invoice       Invoice       @relation(fields: [invoiceId], references: [id]) // onDelete will be determined by Invoice relation
  paymentDate   DateTime      @default(now())
  amount        Float
  paymentMethod PaymentMethod
  referenceId   String? // e.g., transaction ID
  notes         String?
  processedById String? // User ID of staff who processed payment
  schoolId      String
  school        School        @relation(fields: [schoolId], references: [id], onDelete: Restrict)

  @@index([schoolId, invoiceId])
}

model ExpenseCategory {
  id          String    @id @default(cuid())
  name        String
  description String?
  schoolId    String
  school      School    @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  expenses    Expense[]

  @@unique([schoolId, name])
}

model Expense {
  id          String          @id @default(cuid())
  description String
  amount      Float
  date        DateTime
  categoryId  String
  category    ExpenseCategory @relation(fields: [categoryId], references: [id])
  vendorId    String?
  vendor      Vendor?         @relation(fields: [vendorId], references: [id], onDelete: SetNull)
  receiptUrl  String?
  paidById    String // User ID of staff who made the payment/expense
  schoolId    String
  school      School          @relation(fields: [schoolId], references: [id], onDelete: Cascade)

  @@index([schoolId, date])
}

model LeaveType {
  id                String             @id @default(cuid())
  name              String
  defaultDays       Int? // Default number of days for this leave type per year/period
  schoolId          String
  school            School             @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  leaveApplications LeaveApplication[]

  @@unique([schoolId, name])
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

model LeaveApplication {
  id           String      @id @default(cuid())
  staffId      String
  staff        Staff       @relation(fields: [staffId], references: [id])
  leaveTypeId  String
  leaveType    LeaveType   @relation(fields: [leaveTypeId], references: [id])
  startDate    DateTime
  endDate      DateTime
  reason       String?
  status       LeaveStatus @default(PENDING)
  approvedById String? // User ID of admin/manager who approved/rejected
  comments     String?
  appliedOn    DateTime    @default(now())
  schoolId     String
  school       School      @relation(fields: [schoolId], references: [id], onDelete: Cascade)

  @@index([schoolId, staffId, status])
}

model PayrollRecord {
  id             String    @id @default(cuid())
  staffId        String
  staff          Staff     @relation(fields: [staffId], references: [id])
  payPeriodStart DateTime
  payPeriodEnd   DateTime
  basicSalary    Float
  allowances     Float?
  deductions     Float?
  netSalary      Float
  paymentDate    DateTime?
  isPaid         Boolean   @default(false)
  schoolId       String
  school         School    @relation(fields: [schoolId], references: [id], onDelete: Cascade)

  @@unique([staffId, payPeriodStart, payPeriodEnd])
  @@index([schoolId])
}

model Vendor {
  id             String          @id @default(cuid())
  name           String
  contactPerson  String?
  email          String?
  phone          String?
  address        String?
  schoolId       String
  school         School          @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  purchaseOrders PurchaseOrder[]
  expenses       Expense[]

  @@unique([schoolId, name])
  @@index([schoolId])
}

enum PurchaseOrderStatus {
  PENDING
  APPROVED
  REJECTED
  ORDERED
  PARTIALLY_RECEIVED
  RECEIVED
  CANCELLED
}

model PurchaseOrder {
  id                   String              @id @default(cuid())
  orderNumber          String              @unique // Should be unique per school, or globally?
  vendorId             String
  vendor               Vendor              @relation(fields: [vendorId], references: [id])
  orderDate            DateTime            @default(now())
  expectedDeliveryDate DateTime?
  totalAmount          Float
  status               PurchaseOrderStatus @default(PENDING)
  notes                String?
  approvedById         String? // User ID of approver
  schoolId             String
  school               School              @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  items                PurchaseOrderItem[]

  @@index([schoolId, vendorId])
}

model PurchaseOrderItem {
  id              String         @id @default(cuid())
  purchaseOrderId String
  purchaseOrder   PurchaseOrder  @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  itemName        String
  description     String?
  quantity        Int
  unitPrice       Float
  totalPrice      Float // quantity * unitPrice
  inventoryItemId String? // Optional link to an inventory item
  inventoryItem   InventoryItem? @relation(fields: [inventoryItemId], references: [id], onDelete: SetNull)
  schoolId        String
  school          School         @relation(fields: [schoolId], references: [id], onDelete: Restrict)

  @@index([schoolId])
}

model InventoryCategory {
  id       String          @id @default(cuid())
  name     String
  schoolId String
  school   School          @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  items    InventoryItem[]

  @@unique([schoolId, name])
}

model InventoryItem {
  id                 String              @id @default(cuid())
  name               String
  description        String?
  categoryId         String?
  category           InventoryCategory?  @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  quantityInStock    Int                 @default(0)
  reorderLevel       Int? // Alert when quantity falls below this
  supplierInfo       String?
  schoolId           String
  school             School              @relation(fields: [schoolId], references: [id], onDelete: Cascade)
  purchaseOrderItems PurchaseOrderItem[]

  @@unique([schoolId, name]) // Item name unique per school
  @@index([schoolId])
}
